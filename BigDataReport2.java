import java.util.*;

public class BigDataReport2 {

    private static List<Integer> list = new ArrayList<>();
    public static void main(String[] args) {
        /* 
        가비지 컬렉션은 프로그래밍 언어에서 메모리 관리를 위해 사용되는 기술이다. 
        가비지 컬렉션은 메모리에서 더 이상 사용되지 않는 객체들을 식별하여 자동으로 해제하는 프로세스를 말한다. 
        이는 프로그래머가 직접 메모리를 할당하고 해제하는 번거로움과 실수를 줄여주는데 도움을 준다.

        가비지 컬렉션의 필요성은 다음과 같은 이유로 설명할 수 있다:

        자동 메모리 관리: 가비지 컬렉션은 프로그래머가 명시적으로 메모리를 해제하는 작업을 수행하지 않아도 되게 해준다. 
        이는 메모리 누수(memory leaks)와 같은 일반적인 버그를 방지하고 프로그래밍 생산성을 향상시킨다.

        동적 메모리 할당: 많은 프로그래밍 언어에서는 동적으로 메모리를 할당하는 기능을 제공한다. 
        가비지 컬렉션은 동적으로 할당된 메모리를 추적하고 해제함으로써 프로그래머가 메모리 관리에 신경 쓰지 않고도 유연한 데이터 구조를 만들 수 있도록 한다.

        가비지 컬렉션의 동작 메커니즘은 언어 및 구현에 따라 다소 다를 수 있지만, 일반적으로 다음과 같은 방법을 사용한다.:

        Reachability Analysis(도달성 분석): 가비지 컬렉션은 더 이상 참조되지 않는 객체를 식별하여 해제한다. 
        이를 위해 가비지 컬렉션 시스템은 주어진 객체가 여전히 유효한 참조로부터 도달 가능한지 여부를 판단한다. 
        즉, 어떤 객체에 대한 참조 체인을 따라가며 그 객체를 참조하는 다른 객체들을 확인하는 과정을 거친다. 
        도달 가능하지 않은 객체는 가비지로 간주되고 해제된다.
        
        Mark and Sweep(표시 및 정리): 이 방법은 가장 일반적으로 사용되는 가비지 컬렉션 알고리즘이다. 
        가비지 컬렉션 시스템은 모든 객체를 순회하면서 참조되고 있는 객체들을 표시한다.(마킹). 
        그런 다음, 마킹되지 않은 객체들은 도달할 수 없는 객체로 간주되고 해제된다(스위핑).

        Generational Collection(세대별 수집): 이 방법은 객체들을 세대별로 관리하고 수집하는 가비지 컬렉션 기법이다. 
        대부분의 객체는 짧은 지속성을 가지며, 오래된 객체에서 새로운 객체로의 참조는 상대적으로 적은 경우가 많다. 
        따라서 이러한 특성을 활용하여 가비지 컬렉션을 효율적으로 수행할 수 있다.
        세대별 수집은 객체를 여러 세대로 분류하고, 객체의 생성 주기에 따라 수집 방법을 다르게 적용한다. 
        보통 2세대로 구성된 세대별 가비지 컬렉션 기법을 사용한다.

        1세대(Young Generation): 새로 생성된 객체들이 할당되는 영역이다. 
        대부분의 객체는 짧은 지속성을 가지며, 대부분의 객체가 여기에서 사라지게 된다. 
        일반적으로 복사 수집(Copying Collection) 알고리즘이 사용되며, 객체를 두 영역으로 나누어 하나는 비워놓고 다른 하나에 객체를 할당한다. 
        그리고 비워진 영역의 객체는 해제된다.

        2세대(Old Generation): Young Generation에서 살아남은 객체들이 이곳으로 이동한다. 
        이 영역의 객체는 상대적으로 오래 지속된다. 
        일반적으로 Mark and Sweep 알고리즘이 사용되며, 도달 가능한 객체를 마킹하고, 마킹되지 않은 객체는 해제된다.

        세대별 수집을 통해 가비지 컬렉션의 효율성을 향상시킬 수 있다. 
        주로 Young Generation에서 많은 객체가 사라지므로 복사 수집과 같은 단순하고 빠른 알고리즘을 적용하고, 
        Old Generation은 적은 수의 객체를 대상으로 복잡한 알고리즘을 사용하여 가비지를 수집한다.

        이는 가비지 컬렉션의 필요성과 동작 메커니즘의 일부분에 대한 설명이며, 
        구체적인 가비지 컬렉션 알고리즘은 프로그래밍 언어와 해당 실행 환경에 따라 다를 수 있다.

        자바에서는 다음의 두 가지 방법을 주로 이용한다.
        1. Stop The World(STW)
        Stop The World는 가비지 컬렉션을 실행하기 위해 JVM이 애플리케이션의 실행을 멈추는 작업이다. 
        GC가 실행될 때는 GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업이 중단되고, GC가 완료되면 작업이 재개된다. 
        당연히 모든 쓰레드들의 작업이 중단되면 애플리케이션이 멈추기 때문에, GC의 성능 개선을 위해 튜닝을 한다고 
        하면 보통 stop-the-world의 시간을 줄이는 작업을 하는 것이다. 
        또한 JVM에서도 이러한 문제를 해결하기 위해 다양한 실행 옵션을 제공하고 있다.

        2. Mark and Sweep
        Mark: 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업
        Sweep: Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업
        Stop The World를 통해 모든 작업을 중단시키면, GC는 스택의 모든 변수 또는 Reachable 객체를 스캔하면서 각각이 어떤 객체를 참고하고 있는지를 탐색하게 된다. 
        그리고 사용되고 있는 메모리를 식별하는데, 이러한 과정을 Mark라고 한다. 
        이후에 Mark가 되지 않은 객체들을 메모리에서 제거하는데, 이러한 과정을 Sweep라고 한다.

        자바에서 가비지 컬렉션이 제대로 동작하도록 코드를 작성하려면 몇 가지 지침을 따라야 한다. 
        여기에는 객체 참조 관리, 메모리 사용 패턴 및 명시적인 자원 해제 등이 포함된다.

        객체 참조 관리: 가비지 컬렉션은 도달 가능한 객체만을 유지하고 나머지 객체를 해제한다. 
        따라서 객체를 더 이상 사용하지 않는 경우 해당 객체의 참조를 명시적으로 제거해야 한다. 
        객체의 참조를 유지하지 않는 것은 중요하다. 예를 들어, 객체가 컬렉션에 저장되어 있다면, 해당 객체를 사용하지 않을 때 컬렉션에서 제거해야 한다.

        메모리 사용 패턴: 너무 많은 객체를 생성하고 오래 유지하는 것은 가비지 컬렉션의 효율성을 떨어뜨릴 수 있다. 
        객체가 더 이상 필요하지 않은 경우 적시에 해제하도록 노력해야 한다. 
        불필요한 객체 생성을 피하고, 임시 객체나 불필요한 캐싱을 최소화하여 메모리 사용을 최적화해야 한다.

        명시적인 자원 해제: 가비지 컬렉션은 메모리 관리에만 관여한다. 
        그러나 자원 해제(파일, 네트워크 연결, 데이터베이스 연결 등)는 가비지 컬렉션의 영역이 아니다. 
        이러한 자원들은 명시적으로 해제해야 한다. 일반적으로 try-finally 또는 try-with-resources 구문을 사용하여 자원을 안전하게 해제하는 것이 좋다.

        가비지 컬렉션으로 인해 메모리 누수가 발생할 수 있는 경우에는 다음과 같은 상황을 주의해야 한다.:

        강한 참조: 객체 간에 강한 참조가 유지되면 가비지 컬렉션이 발생하지 않는다. 
        객체가 더 이상 필요하지 않더라도 해당 객체에 대한 강한 참조가 남아있는 경우, 해당 객체는 가비지로 간주되지 않고 메모리에 계속 남게 된다. 
        따라서 필요하지 않은 객체의 참조를 명시적으로 제거해야 한다.
        */ 
        for (int i = 0; i < 1000000; i++) {
            list.add(i);
        }

        list = null;
        // list를 null로 설정하더라도 list에 추가된 객체들이 강한 참조에 의해 계속 유지되기 때문에, 
        // 체들은 메모리에서 해제되지 않고 유지된다. 이는 메모리 누수로 이어질 수 있다.

        /*
        잘못된 스코프 관리: 객체의 스코프를 잘못 관리하면 가비지 컬렉션에 의해 메모리 누수가 발생할 수 있다. 
        예를 들어, 객체를 정적 변수에 저장하고 프로그램 수명 동안 유지하는 경우 해당 객체는 가비지 컬렉션에 의해 해제되지 않는다. 
        이런 경우, 객체가 더 이상 필요하지 않을 때 명시적으로 참조를 해제해야 한다. 
        또한, 객체를 컬렉션에 저장한 후에도 필요 없어진 경우에는 컬렉션에서 제거해야 한다.
        */
        while (true) {
            HeavyResource resource = new HeavyResource();
            // resource 변수가 스코프를 벗어나지 않고 유지되므로 메모리 누수 발생
        }

        /*
        순환 참조: 순환 참조는 객체들 사이에 서로 참조가 발생하여 가비지 컬렉션에 의해 제거되지 않는 상황을 말한다. 
        예를 들어, 객체 A가 B를 참조하고 B가 다시 A를 참조하는 경우, 두 객체는 서로 도달 가능하며 가비지로 처리되지 않는다. 
        이런 순환 참조를 방지하기 위해 약한 참조(Weak Reference)나 소프트 참조(Soft Reference)와 같은 가비지 컬렉션을 위한 참조 타입을 사용할 수 있다.
        */
        Node nodeA = new Node("Node A");
        Node nodeB = new Node("Node B");

        nodeA.setNext(nodeB);
        nodeB.setNext(nodeA);

        nodeA = null;
        nodeB = null;

        // nodeA는 nodeB를 가리키고, nodeB는 다시 nodeA를 가리키는 순환 참조 관계가 형성된다.
        // 순환 참조로 인해 nodeA와 nodeB 객체는 가비지 컬렉터에 의해 도달할 수 없는 상태가 아니게 된다.

        /*
        너무 오래 실행되는 작업: 가비지 컬렉션은 일시 중지되는 작업이므로 긴 실행 시간을 가진 작업은 가비지 컬렉션의 효율성에 영향을 줄 수 있다. 
        예를 들어, 긴 반복문이나 큰 데이터 처리 작업이 가비지 컬렉션을 계속해서 일으킬 수 있다. 
        이런 경우, 작업을 분할하거나 가비지 컬렉션의 작동 방식을 조정하여 최적화할 필요가 있을 수 있다.
        */
        Worker worker = new Worker();
        worker.start();
        // 위의 코드에서는 MemoryLeakExample 클래스에서 Worker 클래스를 생성하고 start 메서드를 호출하여 작업을 수행하는 쓰레드를 시작한다.
        // 그러나 주목할 점은 Worker 쓰레드가 계속해서 실행되고 있고, 해당 쓰레드는 Worker 객체에 대한 강한 참조를 유지한다는 것이다. 
        // 즉, 메인 쓰레드는 더 이상 worker 객체를 필요로 하지 않지만, Worker 객체는 아직 실행 중인 쓰레드에 의해 참조되고 있어 가비지 컬렉터가 회수할 수 없는 상태이다.

        /*
        가비지 컬렉션의 효율적인 동작을 위해 코드를 작성할 때, 객체의 참조를 적절하게 관리하고 필요 없는 객체를 명시적으로 해제해야 한다. 
        또한, 순환 참조와 같은 특수한 상황을 주의하여 해결하는 것이 중요하다. 
        자바는 자체적으로 가비지 컬렉션을 처리하기 때문에 메모리 관리에 대한 큰 부담을 덜어준다. 
        그러나 명시적인 자원 해제와 객체 참조 관리에 주의를 기울이는 것은 여전히 중요하다. 
        */
    }
}

class HeavyResource {

}

class Node {
    private String data;
    private Node next;

    public Node(String data) {
        this.data = data;
    }

    public void setNext(Node next) {
        this.next = next;
    }
}

class Worker extends Thread {
    private boolean running = true;

    @Override
    public void run() {
        while (running) {
            // Perform long-running task

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}